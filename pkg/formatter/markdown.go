package formatter

import (
	"fmt"
	"strings"

	"github.com/kvizadsaderah/infrasync/pkg/parser"
)

// MarkdownFormatter formats plan output as GitHub-flavored markdown
type MarkdownFormatter struct {
	ShowDetails   bool
	CompactMode   bool
	ShowUnchanged bool
}

// NewMarkdownFormatter creates a new markdown formatter
func NewMarkdownFormatter(showDetails, compact, showUnchanged bool) *MarkdownFormatter {
	return &MarkdownFormatter{
		ShowDetails:   showDetails,
		CompactMode:   compact,
		ShowUnchanged: showUnchanged,
	}
}

// Format outputs the plan summary as markdown
func (f *MarkdownFormatter) Format(summary *parser.PlanSummary) string {
	var sb strings.Builder

	// Header
	sb.WriteString("## üîÑ Terraform Plan Summary\n\n")

	// Quick stats
	f.writeStatistics(&sb, summary)

	// Warnings
	if summary.ToDelete > 0 || summary.ToReplace > 0 {
		sb.WriteString("\n")
		sb.WriteString("### ‚ö†Ô∏è Warning: Destructive Changes Detected\n\n")
		sb.WriteString("This plan includes destructive changes. Please review carefully:\n\n")
		if summary.ToDelete > 0 {
			sb.WriteString(fmt.Sprintf("- **%d resource(s) will be DESTROYED**\n", summary.ToDelete))
		}
		if summary.ToReplace > 0 {
			sb.WriteString(fmt.Sprintf("- **%d resource(s) will be REPLACED** (destroyed and recreated)\n", summary.ToReplace))
		}
	}

	// Changes by type
	if !f.CompactMode {
		f.writeChangesByType(&sb, summary)
	}

	// Footer
	sb.WriteString("\n---\n")
	sb.WriteString(fmt.Sprintf("*Generated by [InfraSync](https://github.com/kvizadsaderah/infrasync) ‚Ä¢ Terraform %s*\n", summary.TerraformVersion))

	return sb.String()
}

func (f *MarkdownFormatter) writeStatistics(sb *strings.Builder, summary *parser.PlanSummary) {
	sb.WriteString("### üìä Changes Overview\n\n")

	if summary.ToCreate == 0 && summary.ToUpdate == 0 && summary.ToReplace == 0 && summary.ToDelete == 0 {
		sb.WriteString("‚úÖ **No changes.** Infrastructure is up-to-date.\n")
		return
	}

	sb.WriteString("| Action | Count |\n")
	sb.WriteString("|--------|-------|\n")

	if summary.ToCreate > 0 {
		sb.WriteString(fmt.Sprintf("| ‚úÖ **Create** | %d |\n", summary.ToCreate))
	}
	if summary.ToUpdate > 0 {
		sb.WriteString(fmt.Sprintf("| üîÑ **Update** | %d |\n", summary.ToUpdate))
	}
	if summary.ToReplace > 0 {
		sb.WriteString(fmt.Sprintf("| ‚ö†Ô∏è **Replace** | %d |\n", summary.ToReplace))
	}
	if summary.ToDelete > 0 {
		sb.WriteString(fmt.Sprintf("| ‚ùå **Destroy** | %d |\n", summary.ToDelete))
	}
	if summary.NoChanges > 0 && f.ShowUnchanged {
		sb.WriteString(fmt.Sprintf("| ‚ö™ **No Change** | %d |\n", summary.NoChanges))
	}

	total := summary.ToCreate + summary.ToUpdate + summary.ToReplace + summary.ToDelete
	sb.WriteString(fmt.Sprintf("| **Total** | **%d** |\n", total))
}

func (f *MarkdownFormatter) writeChangesByType(sb *strings.Builder, summary *parser.PlanSummary) {
	// Create
	creates := f.filterChanges(summary.Changes, func(c parser.ResourceChange) bool { return c.IsCreate })
	if len(creates) > 0 {
		sb.WriteString("\n<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>‚úÖ <b>Resources to CREATE (%d)</b></summary>\n\n", len(creates)))
		sb.WriteString("```diff\n")
		for _, c := range creates {
			sb.WriteString(fmt.Sprintf("+ %s\n", c.Address))
			if f.ShowDetails {
				sb.WriteString(fmt.Sprintf("  Type: %s\n", c.Type))
			}
		}
		sb.WriteString("```\n")
		sb.WriteString("</details>\n")
	}

	// Update
	updates := f.filterChanges(summary.Changes, func(c parser.ResourceChange) bool { return c.IsUpdate })
	if len(updates) > 0 {
		sb.WriteString("\n<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>üîÑ <b>Resources to UPDATE (%d)</b></summary>\n\n", len(updates)))
		sb.WriteString("```diff\n")
		for _, c := range updates {
			sb.WriteString(fmt.Sprintf("~ %s\n", c.Address))
			if f.ShowDetails {
				sb.WriteString(fmt.Sprintf("  Type: %s\n", c.Type))
				f.writeAttributeDiffMarkdown(sb, c)
			}
		}
		sb.WriteString("```\n")
		sb.WriteString("</details>\n")
	}

	// Replace
	replaces := f.filterChanges(summary.Changes, func(c parser.ResourceChange) bool { return c.IsReplace })
	if len(replaces) > 0 {
		sb.WriteString("\n<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>‚ö†Ô∏è <b>Resources to REPLACE (%d)</b></summary>\n\n", len(replaces)))
		sb.WriteString("> **Warning:** These resources will be destroyed and recreated.\n\n")
		sb.WriteString("```diff\n")
		for _, c := range replaces {
			sb.WriteString(fmt.Sprintf("!‚ü≥ %s\n", c.Address))
			if f.ShowDetails {
				sb.WriteString(fmt.Sprintf("  Type: %s\n", c.Type))
			}
		}
		sb.WriteString("```\n")
		sb.WriteString("</details>\n")
	}

	// Delete
	deletes := f.filterChanges(summary.Changes, func(c parser.ResourceChange) bool { return c.IsDelete })
	if len(deletes) > 0 {
		sb.WriteString("\n<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>‚ùå <b>Resources to DESTROY (%d)</b></summary>\n\n", len(deletes)))
		sb.WriteString("> **Danger:** These resources will be permanently deleted.\n\n")
		sb.WriteString("```diff\n")
		for _, c := range deletes {
			sb.WriteString(fmt.Sprintf("- %s\n", c.Address))
			if f.ShowDetails {
				sb.WriteString(fmt.Sprintf("  Type: %s\n", c.Type))
			}
		}
		sb.WriteString("```\n")
		sb.WriteString("</details>\n")
	}
}

func (f *MarkdownFormatter) writeAttributeDiffMarkdown(sb *strings.Builder, change parser.ResourceChange) {
	before := change.Before
	after := change.After

	allKeys := make(map[string]bool)
	for k := range before {
		allKeys[k] = true
	}
	for k := range after {
		allKeys[k] = true
	}

	count := 0
	for key := range allKeys {
		beforeVal, existsBefore := before[key]
		afterVal, existsAfter := after[key]

		if existsBefore && existsAfter {
			beforeStr := formatValue(beforeVal)
			afterStr := formatValue(afterVal)
			if beforeStr != afterStr {
				sb.WriteString(fmt.Sprintf("  ~ %s: %s ‚Üí %s\n", key, beforeStr, afterStr))
				count++
			}
		} else if existsAfter {
			sb.WriteString(fmt.Sprintf("  + %s: %s\n", key, formatValue(afterVal)))
			count++
		} else if existsBefore {
			sb.WriteString(fmt.Sprintf("  - %s: %s\n", key, formatValue(beforeVal)))
			count++
		}

		if count >= 5 && !f.ShowDetails {
			sb.WriteString("  ... (truncated)\n")
			break
		}
	}
}

func (f *MarkdownFormatter) filterChanges(changes []parser.ResourceChange, predicate func(parser.ResourceChange) bool) []parser.ResourceChange {
	result := make([]parser.ResourceChange, 0)
	for _, c := range changes {
		if predicate(c) {
			result = append(result, c)
		}
	}
	return result
}

// FormatCompact provides a compact single-line summary for PR titles
func (f *MarkdownFormatter) FormatCompact(summary *parser.PlanSummary) string {
	parts := make([]string, 0)

	if summary.ToCreate > 0 {
		parts = append(parts, fmt.Sprintf("+%d", summary.ToCreate))
	}
	if summary.ToUpdate > 0 {
		parts = append(parts, fmt.Sprintf("~%d", summary.ToUpdate))
	}
	if summary.ToReplace > 0 {
		parts = append(parts, fmt.Sprintf("‚ü≥%d", summary.ToReplace))
	}
	if summary.ToDelete > 0 {
		parts = append(parts, fmt.Sprintf("-%d", summary.ToDelete))
	}

	if len(parts) == 0 {
		return "No changes"
	}

	return strings.Join(parts, " ")
}
